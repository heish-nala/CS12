---
phase: 05-scope-all-routes-and-full-isolation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/auth.ts
  - src/app/api/orgs/[id]/members/route.ts
autonomous: true

must_haves:
  truths:
    - "requireOrgDsoAccess helper exists and combines org membership check + DSO access check in one call"
    - "getUserOrg helper returns the user's org_id from org_members"
    - "PATCH /api/orgs/[id]/members changes a member's role and enforces zero-owner guard"
    - "Admin cannot demote the last owner — returns 403"
  artifacts:
    - path: "src/lib/auth.ts"
      provides: "requireOrgDsoAccess and getUserOrg helpers"
      contains: "requireOrgDsoAccess"
    - path: "src/app/api/orgs/[id]/members/route.ts"
      provides: "PATCH handler for role changes"
      exports: ["GET", "POST", "DELETE", "PATCH"]
  key_links:
    - from: "src/lib/auth.ts"
      to: "org_members table"
      via: "supabaseAdmin query in requireOrgDsoAccess"
      pattern: "from.*org_members"
    - from: "src/lib/auth.ts"
      to: "dsos table"
      via: "supabaseAdmin query to get DSO org_id"
      pattern: "from.*dsos.*org_id"
---

<objective>
Create the two auth helpers that every subsequent route migration depends on (`requireOrgDsoAccess` and `getUserOrg`), plus the missing PATCH handler for org member role changes (MBR-06).

Purpose: These helpers are the foundation for Plans 02 and 03. Without them, no route can be migrated to org-scoped auth. The PATCH handler completes the member management CRUD (SC-4).

Output: Updated `lib/auth.ts` with two new exported functions; updated members route with PATCH handler.
</objective>

<execution_context>
@/Users/alan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-scope-all-routes-and-full-isolation/05-RESEARCH.md
@src/lib/auth.ts
@src/app/api/orgs/[id]/members/route.ts
@src/lib/org-utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add requireOrgDsoAccess and getUserOrg helpers to lib/auth.ts</name>
  <files>src/lib/auth.ts</files>
  <action>
Add two new exported functions to `src/lib/auth.ts`:

**1. `getUserOrg(userId: string)`** — Returns the user's org_id from `org_members`. This is the org-filtered enumeration helper for Category B routes.

```typescript
export async function getUserOrg(
    userId: string
): Promise<{ orgId: string; role: string } | null> {
    const { data } = await supabaseAdmin
        .from('org_members')
        .select('org_id, role')
        .eq('user_id', userId)
        .limit(1)
        .single();
    return data ? { orgId: data.org_id, role: data.role } : null;
}
```

**2. `requireOrgDsoAccess(request, dsoId, requireWrite?, parsedBody?)`** — Combines user identification (session + fallback), org membership verification via DSO's org_id, and per-DSO access check in one call. This replaces `requireDsoAccessWithFallback` as the standard auth check for all DSO-scoped routes.

Signature and return type must match the discriminated union pattern used throughout the codebase:
```typescript
export async function requireOrgDsoAccess(
    request: NextRequest,
    dsoId: string,
    requireWrite = false,
    parsedBody?: { user_id?: string }
): Promise<
    { userId: string; orgId: string; role: string; response?: never } |
    { userId?: never; orgId?: never; role?: never; response: NextResponse }
>
```

Implementation steps inside the function:
1. Get user via `getAuthUser(request)`. If no session, fall back to `searchParams.get('user_id')` then `parsedBody?.user_id`. If none, return 401.
2. Query `dsos` table for `org_id` using `dsoId`. If DSO not found, return 404.
3. Call existing `checkOrgMembership(userId, dso.org_id)`. If not a member, return 403 with `'Not a member of this organization'`.
4. Call existing `checkDsoAccess(userId, dsoId)`. If no access, return 403 with `'Access denied to this workspace'`.
5. If `requireWrite` is true and role lacks write access (checked via existing `hasWriteAccess`), return 403.
6. Return `{ userId, orgId: dso.org_id, role }`.

IMPORTANT: Preserve the `user_id` body fallback pattern — this is critical for production cookie auth reliability (see harmonic-spinning-stream.md plan context). The fallback userId gets the SAME org membership and DSO access checks as session-authenticated users.

Place both functions AFTER the existing `requireDsoAccessWithFallback` function in the file, before the org-related functions section (before `checkOrgMembership`).
  </action>
  <verify>Run `npx tsc --noEmit` from the project root — zero type errors. Grep for `requireOrgDsoAccess` and `getUserOrg` in auth.ts to confirm both exist.</verify>
  <done>Both `requireOrgDsoAccess` and `getUserOrg` are exported from `lib/auth.ts`, follow the discriminated union return pattern, and compile without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Add PATCH handler to /api/orgs/[id]/members for role changes (MBR-06)</name>
  <files>src/app/api/orgs/[id]/members/route.ts</files>
  <action>
Add a `PATCH` export to the existing members route file. This handler changes a member's org-level role (owner/admin/member).

Pattern follows the existing DELETE handler in the same file:
1. Extract `id` from `await params`.
2. Call `requireOrgAccess(request, id, true)` — only admins/owners can change roles. Early return if auth fails.
3. Parse body: `{ user_id: string, role: string }`. Return 400 if either is missing.
4. Validate role with `isValidOrgRole(role)` (already imported). Return 400 if invalid.
5. Look up the target member's current role from `org_members` where `org_id = id` and `user_id = user_id`. Return 404 if not found.
6. **Zero-owner guard**: If the target member's current role is `'owner'` and the new role is NOT `'owner'`, count owners for this org. If count <= 1, return 403 with message: `'Cannot demote the last owner. Transfer ownership first.'` (same message as DELETE handler).
7. Update: `supabaseAdmin.from('org_members').update({ role }).eq('org_id', id).eq('user_id', user_id)`.
8. Return `{ success: true, role }` on success.

Add the PATCH function after the existing DELETE function in the file. Import `isValidOrgRole` from `@/lib/org-utils` (already imported at top of file).
  </action>
  <verify>Run `npx tsc --noEmit` — zero type errors. Run `npm run build` to confirm the route compiles.</verify>
  <done>PATCH /api/orgs/[id]/members exists, validates role, enforces zero-owner guard, and returns updated role on success.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` completes successfully
3. `requireOrgDsoAccess` and `getUserOrg` are exported from `src/lib/auth.ts`
4. PATCH handler exists in `src/app/api/orgs/[id]/members/route.ts`
5. Both new helpers follow the existing discriminated union return pattern
</verification>

<success_criteria>
- Two new auth helpers (`requireOrgDsoAccess`, `getUserOrg`) compile and export correctly
- PATCH /api/orgs/[id]/members handler with zero-owner guard is ready for use
- No existing routes or helpers are broken
- Foundation is set for Plans 02 and 03 to migrate routes
</success_criteria>

<output>
After completion, create `.planning/phases/05-scope-all-routes-and-full-isolation/05-01-SUMMARY.md`
</output>
