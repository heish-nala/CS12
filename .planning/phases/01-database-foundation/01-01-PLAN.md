---
phase: 01-database-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260226000000_add_org_tables.sql
  - supabase/seed.sql
autonomous: true

must_haves:
  truths:
    - "organizations, org_members, and user_profiles tables exist with correct columns and indexes after supabase db reset"
    - "All 3 local seed DSOs have a non-null org_id pointing to the demo organization"
    - "Demo user appears in org_members for the demo org with owner role"
    - "user_dso_access table still exists and has its rows after migration"
    - "supabase db reset completes without errors"
  artifacts:
    - path: "supabase/migrations/20260226000000_add_org_tables.sql"
      provides: "DDL for organizations, org_members, user_profiles tables + org_id on dsos + data backfill"
      contains: "CREATE TABLE organizations"
    - path: "supabase/seed.sql"
      provides: "Demo organization + org_members rows for local dev"
      contains: "INSERT INTO organizations"
  key_links:
    - from: "supabase/migrations/20260226000000_add_org_tables.sql"
      to: "dsos table"
      via: "ALTER TABLE dsos ADD COLUMN org_id"
      pattern: "ALTER TABLE dsos ADD COLUMN org_id"
    - from: "supabase/seed.sql"
      to: "supabase/migrations/20260226000000_add_org_tables.sql"
      via: "seed references tables created by migration"
      pattern: "INSERT INTO organizations"
---

<objective>
Write the Phase 1 migration SQL and update the local seed file, then verify locally with supabase db reset.

Purpose: Create the database foundation for multi-tenant organizations — three new tables, org_id on dsos, and backfill of existing production data — validated locally before touching production.
Output: One migration file + updated seed.sql, both passing `supabase db reset` cleanly.
</objective>

<execution_context>
@/Users/alan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-database-foundation/01-RESEARCH.md
@supabase/seed.sql
@supabase/migrations/20260128000000_fix_activities_client_scope.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration file with org tables, org_id on dsos, and production data backfill</name>
  <files>supabase/migrations/20260226000000_add_org_tables.sql</files>
  <action>
Create the migration file at `supabase/migrations/20260226000000_add_org_tables.sql` following the project's existing migration convention (section headers with `-- ====...` separators, comments explaining each block).

The migration must contain these sections IN THIS ORDER:

**1. CREATE organizations table:**
- `id UUID PRIMARY KEY DEFAULT gen_random_uuid()` (NOT uuid_generate_v4 — use the modern built-in)
- `name TEXT NOT NULL`
- `slug TEXT UNIQUE NOT NULL`
- `created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL`
- `created_at TIMESTAMPTZ DEFAULT NOW()`
- `updated_at TIMESTAMPTZ DEFAULT NOW()`
- Index on `slug`, index on `created_by`
- Trigger: `update_organizations_updated_at` using existing `update_updated_at_column()` function

**2. CREATE org_members table:**
- `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
- `org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE`
- `user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE`
- `role TEXT NOT NULL DEFAULT 'member' CHECK (role IN ('owner', 'admin', 'member'))` — these are org-level roles, NOT the same as user_dso_access roles
- `joined_at TIMESTAMPTZ DEFAULT NOW()`
- `UNIQUE (org_id, user_id)` — one membership per org
- Index on `org_id`, index on `user_id`

**3. CREATE user_profiles table:**
- `id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE` — no auto-generated ID, mirrors auth.users
- `email TEXT NOT NULL`
- `name TEXT` (nullable — not all users have names)
- `created_at TIMESTAMPTZ DEFAULT NOW()`
- `updated_at TIMESTAMPTZ DEFAULT NOW()`
- Trigger: `update_user_profiles_updated_at` using existing `update_updated_at_column()` function

**4. ADD org_id to dsos (nullable first — zero downtime pattern):**
- `ALTER TABLE dsos ADD COLUMN org_id UUID REFERENCES organizations(id) ON DELETE SET NULL;`
- Index: `CREATE INDEX idx_dsos_org_id ON dsos(org_id);`
- Do NOT add NOT NULL yet — that happens in step 6

**5. DATA MIGRATION (production backfill):**

5a. Insert default organization for Alan using `gen_random_uuid()` for the ID. Use `ON CONFLICT (slug) DO NOTHING` for idempotency:
```sql
INSERT INTO organizations (name, slug, created_by)
VALUES ('All Solutions Consulting', 'all-solutions-consulting', '8a84898d-0266-4dc1-b97c-744d70d7a4ec')
ON CONFLICT (slug) DO NOTHING;
```

5b. Backfill all existing DSOs — use slug-based lookup (NOT hardcoded UUID):
```sql
UPDATE dsos SET org_id = (SELECT id FROM organizations WHERE slug = 'all-solutions-consulting') WHERE org_id IS NULL;
```

5c. Insert org_members for Alan (owner) and Claudia (admin). Use `ON CONFLICT DO NOTHING`:
```sql
INSERT INTO org_members (org_id, user_id, role)
SELECT (SELECT id FROM organizations WHERE slug = 'all-solutions-consulting'), '8a84898d-0266-4dc1-b97c-744d70d7a4ec', 'owner'
ON CONFLICT (org_id, user_id) DO NOTHING;

INSERT INTO org_members (org_id, user_id, role)
SELECT (SELECT id FROM organizations WHERE slug = 'all-solutions-consulting'), '6559957c-2ce6-4cea-aa15-f79fb401a685', 'admin'
ON CONFLICT (org_id, user_id) DO NOTHING;
```

5d. Seed user_profiles for Alan and Claudia. Use Claudia's email `claudia@allsolutions.consulting` (she's a Google OAuth user on the allsolutions.consulting domain):
```sql
INSERT INTO user_profiles (id, email, name)
VALUES
    ('8a84898d-0266-4dc1-b97c-744d70d7a4ec', 'alan@allsolutions.consulting', 'Alan Hsieh'),
    ('6559957c-2ce6-4cea-aa15-f79fb401a685', 'claudia@allsolutions.consulting', 'Claudia')
ON CONFLICT (id) DO NOTHING;
```

**6. CONSTRAIN dsos.org_id NOT NULL** (after backfill is complete):
```sql
ALTER TABLE dsos ALTER COLUMN org_id SET NOT NULL;
```

**7. Valentina access cleanup:**
Remove Valentina's erroneous `user_dso_access` rows. Include clear comment explaining WHY:
```sql
-- Cleanup: Valentina (d0134916-0f52-4556-9fa0-4c66cff3198e) was erroneously granted
-- access to all 5 DSOs via the invite bug. She should have no DSO access.
-- This is independent of the org migration but cleaned up here while addressing data integrity.
DELETE FROM user_dso_access WHERE user_id = 'd0134916-0f52-4556-9fa0-4c66cff3198e';
```

**Important notes:**
- Do NOT add RLS to any new table (supabaseAdmin bypasses RLS — adding it would be dead code)
- Do NOT modify `user_dso_access` table structure (zero-downtime constraint)
- Do NOT use `uuid_generate_v4()` — use `gen_random_uuid()` throughout
- All INSERTs use `ON CONFLICT DO NOTHING` for idempotency
- The org_members and user_profiles INSERTs will fail on local dev (those user IDs don't exist in local auth.users) but that's expected — the ON CONFLICT pattern makes them no-ops rather than errors. The seed.sql handles local dev data.
  </action>
  <verify>
Read the created file and verify:
1. All 7 sections are present in order
2. org_id is added as nullable BEFORE the backfill, NOT NULL added AFTER
3. All INSERTs have ON CONFLICT clauses
4. No RLS statements (no ALTER TABLE ... ENABLE ROW LEVEL SECURITY)
5. No uuid_generate_v4() calls
6. Valentina cleanup block is present
  </verify>
  <done>Migration file exists at supabase/migrations/20260226000000_add_org_tables.sql with all 3 new tables, org_id on dsos, production data backfill, NOT NULL constraint, and Valentina cleanup — all following the three-step zero-downtime pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Update seed.sql for local dev and verify with supabase db reset</name>
  <files>supabase/seed.sql</files>
  <action>
**Part A — Update seed.sql:**

Add the following AFTER the existing `user_dso_access` inserts at the end of seed.sql (before any trailing whitespace). The demo user (`00000000-0000-0000-0000-000000000001`) needs an org to work with locally:

```sql
-- Demo organization for local development
INSERT INTO organizations (id, name, slug, created_by)
VALUES (
    '00000000-0000-0000-0000-000000000100',
    'Demo Organization',
    'demo-org',
    '00000000-0000-0000-0000-000000000001'
);

-- Demo user is owner of demo org
INSERT INTO org_members (org_id, user_id, role)
VALUES (
    '00000000-0000-0000-0000-000000000100',
    '00000000-0000-0000-0000-000000000001',
    'owner'
);

-- Demo user profile
INSERT INTO user_profiles (id, email, name)
VALUES (
    '00000000-0000-0000-0000-000000000001',
    'demo@cs12.com',
    'Demo User'
);

-- Assign all seed DSOs to demo org
UPDATE dsos SET org_id = '00000000-0000-0000-0000-000000000100' WHERE org_id IS NULL;
```

Use a hardcoded UUID for the demo org (`00000000-0000-0000-0000-000000000100`) — predictable IDs are correct for seed data.

**Part B — Run supabase db reset:**

```bash
cd /path/to/cs12-app && supabase db reset
```

This runs all migrations (including the new one) + seed.sql from scratch. It must complete without errors.

**If db reset fails:**
- If it fails on the migration: fix the SQL syntax in the migration file
- If it fails on the seed: fix the seed.sql (likely ordering or missing table)
- If Supabase isn't running: run `supabase start` first, then retry

**Part C — Verify the local state:**

After db reset succeeds, run these verification queries against the local Supabase (port 54321):

```bash
# Verify 3 new tables exist
psql postgresql://postgres:postgres@127.0.0.1:54321/postgres -c "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name IN ('organizations', 'org_members', 'user_profiles') ORDER BY table_name;"

# Verify all 3 seed DSOs have org_id
psql postgresql://postgres:postgres@127.0.0.1:54321/postgres -c "SELECT name, org_id FROM dsos ORDER BY name;"

# Verify demo user is owner in org_members
psql postgresql://postgres:postgres@127.0.0.1:54321/postgres -c "SELECT om.user_id, om.role, o.name FROM org_members om JOIN organizations o ON o.id = om.org_id;"

# Verify user_dso_access still exists
psql postgresql://postgres:postgres@127.0.0.1:54321/postgres -c "SELECT COUNT(*) FROM user_dso_access;"

# Verify user_profiles has demo user
psql postgresql://postgres:postgres@127.0.0.1:54321/postgres -c "SELECT id, email, name FROM user_profiles;"
```

All queries must return expected data. If any fail, investigate and fix.
  </action>
  <verify>
Run `supabase db reset` — must exit 0 with no errors. Then run the 5 verification queries and confirm:
1. `organizations`, `org_members`, `user_profiles` all appear in table list
2. All 3 DSOs have non-null org_id = `00000000-0000-0000-0000-000000000100`
3. Demo user appears in org_members with role = 'owner'
4. user_dso_access has 3 rows (the demo user's 3 DSO access grants)
5. user_profiles has 1 row (demo user)
  </verify>
  <done>seed.sql updated with demo org data, supabase db reset passes cleanly, all 5 verification queries return expected results — local dev environment is fully functional with the new org schema.</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `supabase db reset` exits cleanly (no errors)
2. Three new tables exist: organizations, org_members, user_profiles
3. dsos table has org_id column (NOT NULL)
4. All seed DSOs have org_id pointing to demo org
5. Demo user is owner in org_members
6. user_dso_access table exists with its original rows
7. The migration file follows the three-step NOT NULL pattern (nullable → backfill → constrain)
</verification>

<success_criteria>
- Migration file creates organizations, org_members, user_profiles tables with correct schemas
- dsos.org_id added via three-step zero-downtime pattern
- Production data backfill uses slug-based lookups with ON CONFLICT DO NOTHING
- Valentina access cleanup included
- seed.sql provides complete local dev environment
- `supabase db reset` passes without errors
- All verification queries return expected data
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-foundation/01-01-SUMMARY.md`
</output>
