---
phase: 04-org-context-and-settings-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/orgs/[id]/dsos/route.ts
  - src/app/api/orgs/[id]/dso-access/route.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/orgs/[id]/dsos returns all DSOs belonging to the org (not filtered by user_dso_access)"
    - "GET /api/orgs/[id]/dso-access returns all user_dso_access rows for DSOs in the org"
    - "POST /api/orgs/[id]/dso-access grants a member access to a DSO within the org"
    - "DELETE /api/orgs/[id]/dso-access removes a member's access to a DSO within the org"
    - "All endpoints require org membership; write endpoints require owner/admin role"
  artifacts:
    - path: "src/app/api/orgs/[id]/dsos/route.ts"
      provides: "GET all DSOs in org"
      exports: ["GET"]
    - path: "src/app/api/orgs/[id]/dso-access/route.ts"
      provides: "CRUD for user_dso_access scoped to org"
      exports: ["GET", "POST", "DELETE"]
  key_links:
    - from: "src/app/api/orgs/[id]/dsos/route.ts"
      to: "requireOrgAccess"
      via: "import from @/lib/auth"
      pattern: "requireOrgAccess\\(request, id\\)"
    - from: "src/app/api/orgs/[id]/dso-access/route.ts"
      to: "requireOrgAccess"
      via: "import from @/lib/auth with requireOwnerOrAdmin=true"
      pattern: "requireOrgAccess\\(request, id, true\\)"
    - from: "src/app/api/orgs/[id]/dso-access/route.ts"
      to: "user_dso_access table"
      via: "supabaseAdmin insert/delete"
      pattern: "supabaseAdmin.*from\\('user_dso_access'\\)"
---

<objective>
Create the backend API routes that the org settings UI needs to manage DSO assignments.

Purpose: The settings page (Plan 03) needs to show admins ALL DSOs in the org and manage which members have access to which DSOs. The existing `GET /api/dsos` filters by `user_dso_access` for the requesting user, so it cannot show DSOs the admin isn't personally assigned to. These new routes provide org-scoped DSO listing and user_dso_access CRUD.

Output: Two new route files under `/api/orgs/[id]/` — one for listing org DSOs, one for reading/writing DSO access assignments.
</objective>

<execution_context>
@/Users/alan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-org-context-and-settings-ui/04-RESEARCH.md
@src/app/api/orgs/[id]/members/route.ts
@src/lib/auth.ts
@src/lib/db/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GET /api/orgs/[id]/dsos route</name>
  <files>src/app/api/orgs/[id]/dsos/route.ts</files>
  <action>
Create a new route file `src/app/api/orgs/[id]/dsos/route.ts` with a GET handler.

**Pattern:** Follow the exact same structure as `src/app/api/orgs/[id]/members/route.ts`:
- Import `NextRequest`, `NextResponse` from `next/server`
- Import `supabaseAdmin` from `@/lib/db/client`
- Import `requireOrgAccess` from `@/lib/auth`
- `export async function GET(request, { params })` with `const { id } = await params`
- Call `requireOrgAccess(request, id)` (any org member can view DSOs, NOT admin-only)
- If `authResult.response` exists, return it
- Query: `supabaseAdmin.from('dsos').select('*').eq('org_id', id).or('archived.is.null,archived.eq.false').order('name')`
- On error: return `{ error: 'Failed to fetch DSOs' }` with status 500
- On success: return `{ dsos }` with status 200

**Important:** This queries `dsos WHERE org_id = id`, NOT `user_dso_access`. This gives admins visibility into ALL DSOs in the org regardless of their personal assignments.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compilation. Grep for `requireOrgAccess` in the new file to confirm auth pattern is wired.
  </verify>
  <done>
`GET /api/orgs/[id]/dsos` route exists, compiles, uses `requireOrgAccess` for auth, and queries `dsos` table filtered by `org_id`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GET/POST/DELETE /api/orgs/[id]/dso-access route</name>
  <files>src/app/api/orgs/[id]/dso-access/route.ts</files>
  <action>
Create `src/app/api/orgs/[id]/dso-access/route.ts` with three handlers: GET, POST, DELETE.

**GET handler** (admin/owner only):
- Call `requireOrgAccess(request, id, true)` — the `true` flag requires owner/admin
- Get all DSO IDs in the org: `supabaseAdmin.from('dsos').select('id').eq('org_id', id)`
- Extract `dsoIds` array from result
- If `dsoIds` is empty, return `{ access: [] }` (avoid `.in()` with empty array — Supabase throws)
- Query: `supabaseAdmin.from('user_dso_access').select('user_id, dso_id, role').in('dso_id', dsoIds)`
- Return `{ access }` with status 200. On error: status 500

**POST handler** (admin/owner only):
- Call `requireOrgAccess(request, id, true)`
- Parse body: `{ user_id, dso_id, role }` — default role to `'viewer'` if not provided
- Validate `user_id` and `dso_id` are present (400 if missing)
- Validate DSO belongs to org: `supabaseAdmin.from('dsos').select('id').eq('id', dso_id).eq('org_id', id).single()`
  - If no result: return `{ error: 'DSO not in this organization' }` status 403
- Validate user is an org member: `supabaseAdmin.from('org_members').select('id').eq('org_id', id).eq('user_id', user_id).single()`
  - If no result: return `{ error: 'User is not a member of this organization' }` status 400
- Insert: `supabaseAdmin.from('user_dso_access').insert({ user_id, dso_id, role })`
- On duplicate (error code `23505`): return `{ error: 'User already has access to this DSO' }` status 409
- On success: return `{ success: true }` status 201

**DELETE handler** (admin/owner only):
- Call `requireOrgAccess(request, id, true)`
- Read `user_id` and `dso_id` from URL search params (consistent with DELETE convention in Phase 2)
- Validate both are present (400 if missing)
- Validate DSO belongs to org (same check as POST — 403 if not)
- Delete: `supabaseAdmin.from('user_dso_access').delete().eq('user_id', userId).eq('dso_id', dsoId)`
- On error: status 500. On success: return `{ success: true }` status 200

**Important:** These routes read/write `user_dso_access` — the existing bridge table. They will be deprecated in Phase 5 when `user_dso_access` is removed.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compilation. Grep the file for all three export functions (GET, POST, DELETE). Verify `requireOrgAccess(request, id, true)` is called in all three handlers.
  </verify>
  <done>
`/api/orgs/[id]/dso-access` route exists with GET (list all access), POST (grant access), and DELETE (revoke access) — all admin/owner gated, all operating on `user_dso_access` table scoped to the org's DSOs.
  </done>
</task>

</tasks>

<verification>
1. Both new route files exist and compile: `npx tsc --noEmit` passes
2. `GET /api/orgs/[id]/dsos` queries `dsos WHERE org_id` (not `user_dso_access`)
3. All three dso-access handlers use `requireOrgAccess(request, id, true)` (admin/owner only)
4. POST validates DSO belongs to org AND user is org member before inserting
5. DELETE reads params from URL search params (REST convention from Phase 2)
6. No existing files modified — these are pure additions
</verification>

<success_criteria>
- Two new route files exist under `src/app/api/orgs/[id]/`
- TypeScript compiles without errors
- Routes follow the exact same auth pattern as existing org routes (`requireOrgAccess`)
- DSO listing is org-scoped (not user-scoped) so admins see all DSOs
- DSO access CRUD operates on `user_dso_access` with org membership validation
</success_criteria>

<output>
After completion, create `.planning/phases/04-org-context-and-settings-ui/04-01-SUMMARY.md`
</output>
