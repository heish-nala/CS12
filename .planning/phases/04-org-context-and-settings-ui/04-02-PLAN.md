---
phase: 04-org-context-and-settings-ui
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/contexts/org-context.tsx
  - src/app/layout.tsx
  - src/components/layout/notion-sidebar.tsx
autonomous: true

must_haves:
  truths:
    - "OrgContext fetches the user's org on login and exposes org data (id, name, slug, role) to all child components"
    - "OrgProvider waits for auth to be ready before fetching — no premature 401 calls"
    - "Sidebar header shows the org name instead of hardcoded 'CS12'"
    - "When user has no org (edge case), sidebar falls back to 'CS12'"
  artifacts:
    - path: "src/contexts/org-context.tsx"
      provides: "OrgProvider and useOrg hook"
      exports: ["OrgProvider", "useOrg"]
    - path: "src/app/layout.tsx"
      provides: "OrgProvider wrapping in component tree"
      contains: "OrgProvider"
    - path: "src/components/layout/notion-sidebar.tsx"
      provides: "Org name display in sidebar header"
      contains: "useOrg"
  key_links:
    - from: "src/contexts/org-context.tsx"
      to: "/api/orgs"
      via: "fetch in useEffect"
      pattern: "fetch.*api/orgs"
    - from: "src/contexts/org-context.tsx"
      to: "src/contexts/auth-context.tsx"
      via: "useAuth hook"
      pattern: "useAuth"
    - from: "src/components/layout/notion-sidebar.tsx"
      to: "src/contexts/org-context.tsx"
      via: "useOrg hook"
      pattern: "useOrg"
---

<objective>
Create the OrgContext provider and wire the org name into the sidebar.

Purpose: All Phase 4 UI components need access to the current user's org data (id, name, role). Instead of each component making its own `/api/orgs` call, OrgContext fetches once and shares everywhere — exactly mirroring the existing ClientsContext pattern. The sidebar update gives users an immediate visual indicator of which org they're in (UI-02 partial).

Output: New `org-context.tsx`, modified `layout.tsx` (provider wrapping), modified `notion-sidebar.tsx` (org name display).
</objective>

<execution_context>
@/Users/alan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-org-context-and-settings-ui/04-RESEARCH.md
@src/contexts/clients-context.tsx
@src/contexts/auth-context.tsx
@src/app/layout.tsx
@src/components/layout/notion-sidebar.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OrgContext provider and useOrg hook</name>
  <files>src/contexts/org-context.tsx</files>
  <action>
Create `src/contexts/org-context.tsx` following the EXACT pattern from `src/contexts/clients-context.tsx`.

**Imports:**
```
'use client';
import { createContext, useContext, useState, useCallback, useEffect, ReactNode } from 'react';
import { useAuth } from './auth-context';
import { Organization, OrgRole } from '@/lib/db/types';
```

**Interface `OrgWithRole`:** Extend `Organization` with `role: OrgRole` — this matches the shape returned by `GET /api/orgs` (each org object has a `role` field from the join).

**Interface `OrgContextType`:**
- `org: OrgWithRole | null` — the user's current org (v1: first org from array)
- `loading: boolean`
- `refreshOrg: () => Promise<void>`

**Provider implementation (mirror ClientsContext exactly):**
1. Get `{ user, loading: authLoading }` from `useAuth()`
2. State: `org` (OrgWithRole | null, default null), `loading` (boolean, default true)
3. `fetchOrg` callback:
   - If `!user?.id`: if `!authLoading` set loading false, return
   - `fetch('/api/orgs')` — no user_id param needed, the route reads from session
   - If OK, parse JSON: `data.orgs?.[0] ?? null` (v1: user has one org)
   - If `data.orgs?.length > 1`: `console.warn('User has multiple orgs — using first. Multi-org support is v2 (MORG-02).')`
   - Set `org` state
   - On error: `console.error('Error fetching org:', error)`
   - Finally: `setLoading(false)`
4. `useEffect` — same guard as ClientsContext:
   - If `!authLoading && user?.id` → call `fetchOrg()`
   - If `!authLoading && !user?.id` → set loading false
   - Deps: `[user?.id, authLoading]` with eslint-disable comment
5. Provider value: `{ org, loading, refreshOrg: fetchOrg }`

**`useOrg` hook:**
```
export function useOrg() {
    const context = useContext(OrgContext);
    if (context === undefined) {
        throw new Error('useOrg must be used within an OrgProvider');
    }
    return context;
}
```

**Key detail:** The `GET /api/orgs` response shape is `{ orgs: Array<Organization & { role: OrgRole }> }` — verified in Phase 2 summary. The first element maps directly to `OrgWithRole`.
  </action>
  <verify>
Run `npx tsc --noEmit`. Verify the file exports `OrgProvider` and `useOrg`. Grep for `useAuth` to confirm it depends on auth-context.
  </verify>
  <done>
`OrgContext` provider exists at `src/contexts/org-context.tsx`, exports `OrgProvider` and `useOrg`, fetches from `/api/orgs` after auth is ready, and exposes `{ org, loading, refreshOrg }`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire OrgProvider into layout and show org name in sidebar</name>
  <files>src/app/layout.tsx, src/components/layout/notion-sidebar.tsx</files>
  <action>
**layout.tsx changes:**
1. Add import: `import { OrgProvider } from '@/contexts/org-context';`
2. Insert `<OrgProvider>` inside `<ClientsProvider>` but wrapping `<OnboardingProvider>`:

Before:
```
<AuthProvider>
    <ClientsProvider>
        <OnboardingProvider>
            ...
        </OnboardingProvider>
    </ClientsProvider>
</AuthProvider>
```

After:
```
<AuthProvider>
    <ClientsProvider>
        <OrgProvider>
            <OnboardingProvider>
                ...
            </OnboardingProvider>
        </OrgProvider>
    </ClientsProvider>
</AuthProvider>
```

OrgProvider must be inside AuthProvider (needs user). It can sit at the same level as ClientsProvider since both depend on auth but not each other. Placing it inside ClientsProvider and around OnboardingProvider is clean — it mirrors the nesting pattern.

**notion-sidebar.tsx changes:**
1. Add import: `import { useOrg } from '@/contexts/org-context';`
2. Inside `NotionSidebar` component, add: `const { org } = useOrg();`
3. In the header section (around line 77), replace the hardcoded "CS12" with the org name:

Before:
```
<span className="font-medium text-[14px] text-foreground">CS12</span>
```

After:
```
<span className="font-medium text-[14px] text-foreground truncate">
    {org?.name ?? 'CS12'}
</span>
```

The `truncate` class ensures long org names don't break the sidebar layout. The fallback 'CS12' handles the loading state and edge case where org is null.

**Do NOT change** the "C" logo icon — only the text label changes.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Grep `layout.tsx` for `OrgProvider` to confirm it's in the tree. Grep `notion-sidebar.tsx` for `useOrg` to confirm it reads from context.
  </verify>
  <done>
OrgProvider wraps the component tree in layout.tsx. The sidebar header shows the user's org name (falling back to 'CS12' when org is null/loading).
  </done>
</task>

</tasks>

<verification>
1. `src/contexts/org-context.tsx` exists with `OrgProvider` and `useOrg` exports
2. `src/app/layout.tsx` includes `<OrgProvider>` in the provider chain
3. `src/components/layout/notion-sidebar.tsx` uses `useOrg()` and displays `org?.name`
4. `npx tsc --noEmit` passes
5. OrgContext waits for auth (`!authLoading && user?.id`) before fetching — no premature API calls
</verification>

<success_criteria>
- OrgContext provider mirrors ClientsContext pattern exactly
- Provider is registered in layout.tsx inside the auth boundary
- Sidebar shows dynamic org name instead of hardcoded "CS12"
- TypeScript compiles without errors
- No new packages installed — uses only existing React Context API
</success_criteria>

<output>
After completion, create `.planning/phases/04-org-context-and-settings-ui/04-02-SUMMARY.md`
</output>
