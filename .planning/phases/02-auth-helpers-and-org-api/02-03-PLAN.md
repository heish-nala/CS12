---
phase: 02-auth-helpers-and-org-api
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/app/api/orgs/[id]/members/route.ts
  - supabase/migrations/20260227000001_org_signup_trigger.sql
  - supabase/seed.sql
autonomous: true

must_haves:
  truths:
    - "GET /api/orgs/[id]/members returns all members of the org with their profiles (email, name) and roles"
    - "POST /api/orgs/[id]/members allows an owner or admin to add a member with a valid role"
    - "DELETE /api/orgs/[id]/members rejects removing the last owner with a 403 and clear error message"
    - "A new user signup triggers automatic organization creation with the user as owner"
    - "The auto-created organization has a unique slug derived from the user's email prefix"
  artifacts:
    - path: "src/app/api/orgs/[id]/members/route.ts"
      provides: "GET (list members), POST (add member), DELETE (remove member) with zero-owner guard"
      exports: ["GET", "POST", "DELETE"]
    - path: "supabase/migrations/20260227000001_org_signup_trigger.sql"
      provides: "handle_new_user_signup() function + AFTER INSERT ON auth.users trigger"
      contains: "CREATE OR REPLACE TRIGGER on_auth_user_created"
    - path: "supabase/seed.sql"
      provides: "Updated seed to account for signup trigger firing on auth.users insert"
  key_links:
    - from: "src/app/api/orgs/[id]/members/route.ts"
      to: "src/lib/auth.ts"
      via: "requireOrgAccess with requireOwnerOrAdmin=true"
      pattern: "requireOrgAccess.*true"
    - from: "src/app/api/orgs/[id]/members/route.ts"
      to: "org_members table"
      via: "supabaseAdmin queries with zero-owner guard"
      pattern: "supabaseAdmin.*from.*org_members"
    - from: "supabase/migrations/20260227000001_org_signup_trigger.sql"
      to: "auth.users table"
      via: "AFTER INSERT trigger"
      pattern: "AFTER INSERT ON auth.users"
    - from: "supabase/migrations/20260227000001_org_signup_trigger.sql"
      to: "organizations + org_members + user_profiles tables"
      via: "INSERT statements inside trigger function"
      pattern: "INSERT INTO public.organizations"
---

<objective>
Build the member management API endpoints (list, add, remove members with zero-owner guard) and create the auto-org-on-signup database trigger migration.

Purpose: Member management endpoints (MBR-07, MBR-08) enable owners/admins to control who belongs to their organization. The signup trigger (ORG-01) ensures every new user automatically gets their own organization without manual setup. Together these satisfy the Phase 2 success criteria for role enforcement and auto-org creation.

Output: One new route file (members CRUD), one new migration file (signup trigger), and updated seed.sql.
</objective>

<execution_context>
@/Users/alan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-auth-helpers-and-org-api/02-RESEARCH.md
@.planning/phases/02-auth-helpers-and-org-api/02-01-SUMMARY.md
@src/lib/auth.ts
@src/lib/org-utils.ts
@supabase/migrations/20260226000000_add_org_tables.sql
@supabase/seed.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /api/orgs/[id]/members route (GET, POST, DELETE with zero-owner guard)</name>
  <files>src/app/api/orgs/[id]/members/route.ts</files>
  <action>
  Create `src/app/api/orgs/[id]/members/route.ts` with GET, POST, and DELETE handlers.

  **GET /api/orgs/[id]/members** — List all members with profiles:
  1. Extract `id` from route params (Next.js 16 async params: `const { id } = await params;`).
  2. Call `requireOrgAccess(request, id)`. Any member can view the member list.
  3. Query `org_members` joined with `user_profiles`:
     ```typescript
     const { data: members, error } = await supabaseAdmin
         .from('org_members')
         .select('*, user_profiles(*)')
         .eq('org_id', id)
         .order('joined_at', { ascending: true });
     ```
  4. Return 200 with `{ members }`.

  **POST /api/orgs/[id]/members** — Add a member to the org:
  1. Extract `id` from route params.
  2. Call `requireOrgAccess(request, id, true)` — only owner/admin can add members.
  3. Parse request body. Validate:
     - `user_id` is present (the user to add). This is the Supabase auth user UUID.
     - `role` is present and valid (use `isValidOrgRole` from `@/lib/org-utils`). Default to `'member'` if not provided.
  4. Check if user is already a member:
     ```typescript
     const { data: existing } = await supabaseAdmin
         .from('org_members')
         .select('id')
         .eq('org_id', id)
         .eq('user_id', user_id)
         .single();
     if (existing) {
         return NextResponse.json(
             { error: 'User is already a member of this organization' },
             { status: 409 }
         );
     }
     ```
  5. Insert into `org_members`: `{ org_id: id, user_id, role }`.
  6. Return 201 with `{ member: data }`.

  **DELETE /api/orgs/[id]/members** — Remove a member (with zero-owner guard):
  1. Extract `id` from route params.
  2. Call `requireOrgAccess(request, id, true)` — only owner/admin can remove members.
  3. Parse request body or search params for `user_id` (the member to remove). Accept `user_id` from the request URL search params: `const targetUserId = new URL(request.url).searchParams.get('user_id');`. Validate it is present.
  4. **Zero-owner guard** (MBR-08): Before deleting, check if this would leave zero owners:
     ```typescript
     // Check the target member's current role
     const { data: targetMember } = await supabaseAdmin
         .from('org_members')
         .select('role')
         .eq('org_id', id)
         .eq('user_id', targetUserId)
         .single();

     if (!targetMember) {
         return NextResponse.json(
             { error: 'User is not a member of this organization' },
             { status: 404 }
         );
     }

     if (targetMember.role === 'owner') {
         // Count total owners
         const { count } = await supabaseAdmin
             .from('org_members')
             .select('*', { count: 'exact', head: true })
             .eq('org_id', id)
             .eq('role', 'owner');

         if (count !== null && count <= 1) {
             return NextResponse.json(
                 { error: 'Cannot remove the last owner of an organization. Transfer ownership first.' },
                 { status: 403 }
             );
         }
     }
     ```
  5. Delete the `org_members` row:
     ```typescript
     const { error: deleteError } = await supabaseAdmin
         .from('org_members')
         .delete()
         .eq('org_id', id)
         .eq('user_id', targetUserId);
     ```
  6. Return 200 with `{ success: true }`.

  **Route signature for all handlers:**
  ```typescript
  export async function GET(
      request: NextRequest,
      { params }: { params: Promise<{ id: string }> }
  ) {
      const { id } = await params;
      // ...
  }
  ```

  **Imports:**
  ```typescript
  import { NextRequest, NextResponse } from 'next/server';
  import { supabaseAdmin } from '@/lib/db/client';
  import { requireOrgAccess } from '@/lib/auth';
  import { isValidOrgRole } from '@/lib/org-utils';
  ```
  </action>
  <verify>Run `npx tsc --noEmit`. Verify file exists: `ls src/app/api/orgs/\[id\]/members/route.ts`. Verify all three exports: `grep "export async function" src/app/api/orgs/\[id\]/members/route.ts` shows GET, POST, DELETE.</verify>
  <done>GET returns members with profiles. POST adds members with role validation. DELETE removes members but rejects removing the last owner with a 403. All three handlers use requireOrgAccess.</done>
</task>

<task type="auto">
  <name>Task 2: Create auto-org signup trigger migration and update seed.sql</name>
  <files>supabase/migrations/20260227000001_org_signup_trigger.sql, supabase/seed.sql</files>
  <action>
  **Create migration file** `supabase/migrations/20260227000001_org_signup_trigger.sql`:

  This migration creates a PostgreSQL function and trigger that fires AFTER INSERT on auth.users, automatically creating an organization for the new user and adding them as owner. Per the research, this CAN be in a migration file — Supabase CLI migrations run as postgres superuser.

  ```sql
  -- ============================================================================
  -- Migration: Auto-create organization on user signup
  -- Phase 2: Auth Helpers and Org API (ORG-01)
  -- ============================================================================
  -- When a new user signs up, automatically:
  --   1. Create an organization named "[Name]'s Organization"
  --   2. Add the user as owner in org_members
  --   3. Insert a user_profiles row (idempotent via ON CONFLICT)
  --
  -- Trigger: AFTER INSERT ON auth.users
  -- Security: SECURITY DEFINER (runs as function owner = postgres)
  -- ============================================================================

  -- 1. Create the trigger function
  CREATE OR REPLACE FUNCTION public.handle_new_user_signup()
  RETURNS TRIGGER AS $$
  DECLARE
      new_org_id UUID;
      new_org_slug TEXT;
      base_slug TEXT;
      counter INT := 0;
      user_name TEXT;
  BEGIN
      -- Determine display name from user metadata
      user_name := COALESCE(
          NEW.raw_user_meta_data->>'name',
          NEW.raw_user_meta_data->>'full_name',
          SPLIT_PART(NEW.email, '@', 1)
      );

      -- Generate base slug from email prefix (lowercase, alphanumeric + hyphens only)
      base_slug := LOWER(REGEXP_REPLACE(SPLIT_PART(NEW.email, '@', 1), '[^a-z0-9]', '-', 'g'));
      base_slug := TRIM(BOTH '-' FROM base_slug);
      -- Default if slug is empty after sanitization
      IF base_slug = '' THEN base_slug := 'org'; END IF;

      new_org_slug := base_slug;

      -- Ensure slug uniqueness by appending counter if needed
      WHILE EXISTS (SELECT 1 FROM public.organizations WHERE slug = new_org_slug) LOOP
          counter := counter + 1;
          new_org_slug := base_slug || '-' || counter;
      END LOOP;

      -- Create the organization
      INSERT INTO public.organizations (name, slug, created_by)
      VALUES (user_name || '''s Organization', new_org_slug, NEW.id)
      RETURNING id INTO new_org_id;

      -- Add the user as owner
      INSERT INTO public.org_members (org_id, user_id, role)
      VALUES (new_org_id, NEW.id, 'owner');

      -- Insert user_profiles row (idempotent — Phase 1 may have pre-seeded some users)
      INSERT INTO public.user_profiles (id, email, name)
      VALUES (
          NEW.id,
          NEW.email,
          NULLIF(user_name, SPLIT_PART(NEW.email, '@', 1))
      )
      ON CONFLICT (id) DO NOTHING;

      RETURN NEW;
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;

  -- 2. Create the trigger (fires after each new auth.users insert)
  -- Note: auth schema is accessible to postgres role (migration owner).
  -- The comment in 20250115_add_team_invites.sql was overly conservative.
  CREATE OR REPLACE TRIGGER on_auth_user_created
      AFTER INSERT ON auth.users
      FOR EACH ROW
      EXECUTE FUNCTION public.handle_new_user_signup();
  ```

  **Update seed.sql** to account for the trigger:

  The signup trigger fires on `INSERT INTO auth.users`. The seed.sql already inserts a demo user into auth.users (from Phase 1). When the trigger exists, that INSERT will auto-create an org + org_member + user_profile row for the demo user. This means the seed.sql's manual INSERT INTO organizations (the demo org) and the manual INSERT INTO org_members will CONFLICT.

  The seed.sql already uses `ON CONFLICT DO NOTHING` on org_members and user_profiles (added in Phase 1). However, the organizations INSERT uses a hardcoded UUID (`00000000-0000-0000-0000-000000000100`) and the trigger will create a DIFFERENT org with a generated UUID. This means the demo user will end up with TWO orgs: the trigger-created one and the manual one.

  **Fix approach:** Since the trigger will auto-create an org for the demo user, the seed.sql should:
  1. Keep the manual demo org INSERT (it uses a predictable UUID that the dsos reference via org_id). The `ON CONFLICT` on slug won't fire because the trigger-created org has a different slug (derived from email prefix, e.g., "demo").
  2. BUT: the dsos.org_id references `00000000-0000-0000-0000-000000000100` (the manual org). This still works — the demo DSOs belong to the manually-created org, and the demo user also gets a trigger-created org. The demo user will have 2 orgs (the manual "Demo Organization" and the trigger-created "demo's Organization"). This is acceptable for local dev.
  3. To ensure the demo user is an owner of BOTH orgs, the org_members INSERT for the manual org must use `ON CONFLICT DO NOTHING` (already does from Phase 1).

  **Specific seed.sql change:** Add a comment above the organizations INSERT block explaining that the demo user will also have a trigger-created org, and the manual org is intentional for DSO references:

  Find the comment block above the organizations INSERT in seed.sql and add a clarifying note. The exact edit depends on the current seed.sql structure — read the file first and add a comment like:
  ```sql
  -- Note: The auth.users INSERT above will also trigger handle_new_user_signup(),
  -- which auto-creates an org for the demo user. This manual org is separate and
  -- intentional — the demo DSOs reference its UUID (00000000-0000-0000-0000-000000000100).
  -- The demo user will belong to both orgs in local dev, which is fine for testing.
  ```

  Also ensure the user_profiles INSERT in seed.sql uses `ON CONFLICT (id) DO UPDATE SET email = EXCLUDED.email, name = EXCLUDED.name` instead of `DO NOTHING`, so that the seed.sql values win over the trigger-generated values. This makes the demo user's profile predictable.

  Read the current seed.sql to find the exact lines for the user_profiles INSERT and update accordingly.
  </action>
  <verify>
  1. Verify migration file exists: `ls supabase/migrations/20260227000001_org_signup_trigger.sql`
  2. Verify trigger creation: `grep "CREATE OR REPLACE TRIGGER on_auth_user_created" supabase/migrations/20260227000001_org_signup_trigger.sql`
  3. Verify SECURITY DEFINER: `grep "SECURITY DEFINER" supabase/migrations/20260227000001_org_signup_trigger.sql`
  4. Run `npx tsc --noEmit` (migration is SQL-only but ensure no TS breakage)
  5. Run `npm run build` to confirm full build passes
  </verify>
  <done>Migration file creates handle_new_user_signup() function with SECURITY DEFINER and AFTER INSERT trigger on auth.users. New user signups will auto-create an org with unique slug, add user as owner, and insert user_profiles row. seed.sql is updated with comments explaining the dual-org situation in local dev and user_profiles uses DO UPDATE for predictability.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` passes (full Next.js build)
3. `ls src/app/api/orgs/\[id\]/members/route.ts` — file exists
4. `grep "export async function" src/app/api/orgs/\[id\]/members/route.ts` — shows GET, POST, DELETE
5. `grep "Cannot remove the last owner" src/app/api/orgs/\[id\]/members/route.ts` — zero-owner guard message present
6. `ls supabase/migrations/20260227000001_org_signup_trigger.sql` — migration file exists
7. `grep "on_auth_user_created" supabase/migrations/20260227000001_org_signup_trigger.sql` — trigger name present
8. `grep "SECURITY DEFINER" supabase/migrations/20260227000001_org_signup_trigger.sql` — security context correct
</verification>

<success_criteria>
- GET /api/orgs/[id]/members returns members with user_profiles (email, name, role)
- POST /api/orgs/[id]/members adds a member with role validation, only owner/admin can add
- DELETE /api/orgs/[id]/members removes a member but rejects removing the last owner (403)
- Signup trigger migration exists and will auto-create an org for new users
- seed.sql is consistent with the trigger (no conflicts, predictable local dev state)
- Full build passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-auth-helpers-and-org-api/02-03-SUMMARY.md`
</output>
