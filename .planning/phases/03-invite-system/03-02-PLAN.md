---
phase: 03-invite-system
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/app/api/orgs/[id]/invites/route.ts
  - src/app/api/orgs/accept-invite/route.ts
  - src/app/auth/confirm/route.ts
  - src/contexts/auth-context.tsx
autonomous: true

must_haves:
  truths:
    - "An org owner or admin can invite a user by email — existing users are added to org_members directly, new users receive an invite email"
    - "A new user who clicks the invite link lands at /auth/confirm, gets a session established via verifyOtp, and is redirected into the app"
    - "On SIGNED_IN event, pending org_invites for the user's email are automatically accepted and the user is added to org_members"
    - "A user invited to Org A is added to Org A's org_members only — they cannot see Org B's DSOs"
    - "Duplicate invites (same org + email + pending status) return 409, not a 500 error"
  artifacts:
    - path: "src/app/api/orgs/[id]/invites/route.ts"
      provides: "POST endpoint to send org invite, GET to list pending invites"
      exports: ["POST", "GET"]
    - path: "src/app/api/orgs/accept-invite/route.ts"
      provides: "POST endpoint to accept all pending org_invites for a user's email"
      exports: ["POST"]
    - path: "src/app/auth/confirm/route.ts"
      provides: "GET handler for invite email link — verifies token_hash and establishes session"
      exports: ["GET"]
    - path: "src/contexts/auth-context.tsx"
      provides: "checkAndAcceptOrgInvites function called on SIGNED_IN alongside existing checkAndAcceptInvites"
      contains: "checkAndAcceptOrgInvites"
  key_links:
    - from: "src/app/api/orgs/[id]/invites/route.ts"
      to: "org_invites table"
      via: "supabaseAdmin.from('org_invites').insert"
      pattern: "from\\('org_invites'\\)"
    - from: "src/app/api/orgs/[id]/invites/route.ts"
      to: "supabase auth"
      via: "supabaseAdmin.auth.admin.inviteUserByEmail"
      pattern: "inviteUserByEmail"
    - from: "src/app/auth/confirm/route.ts"
      to: "supabase auth"
      via: "supabase.auth.verifyOtp({ type, token_hash })"
      pattern: "verifyOtp"
    - from: "src/contexts/auth-context.tsx"
      to: "src/app/api/orgs/accept-invite/route.ts"
      via: "fetch('/api/orgs/accept-invite')"
      pattern: "/api/orgs/accept-invite"
    - from: "src/app/api/orgs/accept-invite/route.ts"
      to: "org_invites + org_members tables"
      via: "query org_invites by email, insert into org_members"
      pattern: "from\\('org_members'\\)"
---

<objective>
Build the complete org-scoped invite flow: send invite API, auth confirm route for invite email links, accept-invite API, and auth-context integration.

Purpose: This delivers MBR-01 (admin can invite by email) and MBR-02 (invited user can accept and join). Combined with Plan 01's bug fix, this completes Phase 3's goal of org-scoped invites.

Output: Four files — invite send endpoint, accept-invite endpoint, auth confirm route handler, and updated auth-context.
</objective>

<execution_context>
@/Users/alan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-invite-system/03-RESEARCH.md
@.planning/phases/03-invite-system/03-01-SUMMARY.md

@src/lib/auth.ts
@src/lib/org-utils.ts
@src/lib/db/client.ts
@src/app/api/orgs/[id]/members/route.ts
@src/contexts/auth-context.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create org invite send and list endpoints</name>
  <files>
    src/app/api/orgs/[id]/invites/route.ts
  </files>
  <action>
Create a new route file at `src/app/api/orgs/[id]/invites/route.ts` with POST and GET handlers.

**POST handler (send invite):**

Follow the exact pattern from `src/app/api/orgs/[id]/members/route.ts` for auth and structure.

1. Extract `orgId` from `params` (same `{ params }: { params: Promise<{ id: string }> }` pattern)
2. Call `requireOrgAccess(request, id, true)` — owner/admin only
3. Parse body: `{ email, role }` — `role` defaults to `'member'` if not provided
4. Validate email format (same regex as existing team invite: `/^[^\s@]+@[^\s@]+\.[^\s@]+$/`)
5. Validate role with `isValidOrgRole(role)` from `@/lib/org-utils`
6. Normalize email: `email.toLowerCase().trim()`
7. Prevent self-invite: compare normalized email against `user.email`

**Two branches based on whether user exists:**

Branch A — Existing user (found in `user_profiles` by email):
```typescript
const { data: existingProfile } = await supabaseAdmin
    .from('user_profiles')
    .select('id')
    .eq('email', normalizedEmail)
    .single();
```
- If existingProfile found, check if already an org member:
  ```typescript
  const { data: existingMember } = await supabaseAdmin
      .from('org_members')
      .select('id')
      .eq('org_id', orgId)
      .eq('user_id', existingProfile.id)
      .single();
  ```
- If already a member: return `409 { error: 'User is already a member of this organization' }`
- If NOT a member: insert directly into `org_members` (`{ org_id: orgId, user_id: existingProfile.id, role }`) and return `{ success: true, added_directly: true }`
- Do NOT call `inviteUserByEmail` for existing users — it fails for registered users

Branch B — New user (no profile found):
- Insert into `org_invites`: `{ org_id: orgId, email: normalizedEmail, role, invited_by: user.id, expires_at }`
  - `expires_at` = `new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()`
  - Handle `23505` (unique constraint) as 409: `{ error: 'A pending invite already exists for this email' }`
- Call `supabaseAdmin.auth.admin.inviteUserByEmail(normalizedEmail, { data: { org_id: orgId, invite_id: invite.id, role }, redirectTo: \`\${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/auth/confirm\` })`
- If `inviteUserByEmail` fails: rollback the `org_invites` row and return 500
- Return `{ success: true, invite: { id, email, role, expires_at } }`

**GET handler (list pending invites):**

1. Extract `orgId` from params
2. Call `requireOrgAccess(request, id)` — any member can view (matching the members list pattern)
3. Query `org_invites` where `org_id = orgId`, `status = 'pending'`, `expires_at > now()`
4. Order by `created_at DESC`
5. Return `{ invites }`

Imports needed:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/db/client';
import { requireOrgAccess } from '@/lib/auth';
import { isValidOrgRole } from '@/lib/org-utils';
```
  </action>
  <verify>
1. `npm run build` passes
2. POST handler uses `requireOrgAccess(request, id, true)` (owner/admin only)
3. POST handler has two branches: existingProfile (add directly to org_members) vs new user (inviteUserByEmail + org_invites)
4. POST handler handles 23505 as 409
5. POST handler does NOT call `listUsers()`
6. GET handler queries `org_invites` filtered by org_id, status='pending', and non-expired
  </verify>
  <done>
`POST /api/orgs/[id]/invites` sends org-scoped invites with correct branching (existing users added directly, new users get email). `GET /api/orgs/[id]/invites` lists pending invites for the org.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auth confirm route + accept-invite endpoint + auth-context integration</name>
  <files>
    src/app/auth/confirm/route.ts
    src/app/api/orgs/accept-invite/route.ts
    src/contexts/auth-context.tsx
  </files>
  <action>
**File 1 — `src/app/auth/confirm/route.ts` (NEW):**

This is the most critical new file. When `inviteUserByEmail` sends an email, the link contains `token_hash` and `type=invite`. This route verifies the token and establishes a session.

```typescript
import { type EmailOtpType } from '@supabase/supabase-js';
import { type NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function GET(request: NextRequest) {
    const { searchParams } = new URL(request.url);
    const token_hash = searchParams.get('token_hash');
    const type = searchParams.get('type') as EmailOtpType | null;
    const next = searchParams.get('next') ?? '/';

    if (token_hash && type) {
        const cookieStore = await cookies();
        const supabase = createServerClient(
            process.env.NEXT_PUBLIC_SUPABASE_URL!,
            process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
            {
                cookies: {
                    getAll() { return cookieStore.getAll(); },
                    setAll(cookiesToSet) {
                        cookiesToSet.forEach(({ name, value, options }) =>
                            cookieStore.set(name, value, options)
                        );
                    },
                },
            }
        );

        const { error } = await supabase.auth.verifyOtp({ type, token_hash });

        if (!error) {
            // Session established — redirect to app
            // auth-context.tsx will fire SIGNED_IN → checkAndAcceptOrgInvites
            return NextResponse.redirect(new URL(next.startsWith('/') ? next : '/', request.url));
        }
    }

    // Invalid or expired token — redirect to login with error
    return NextResponse.redirect(new URL('/login?error=invalid_invite', request.url));
}
```

Key points:
- Do NOT use PKCE (`exchangeCodeForSession`) — Supabase does not support PKCE for invite links
- Use `verifyOtp` with `type` and `token_hash` — the official App Router pattern
- `cookies()` must be awaited (Next.js 16 requirement)
- Uses `createServerClient` from `@supabase/ssr` (already a dependency)

**File 2 — `src/app/api/orgs/accept-invite/route.ts` (NEW):**

Accepts all pending org_invites for a user's email. Called from auth-context on SIGNED_IN.

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/db/client';
import { requireAuth } from '@/lib/auth';

export async function POST(request: NextRequest) {
    try {
        const body = await request.json();
        const { user_id, email } = body;

        // Try session auth first, fall back to user_id from body
        // (same pattern as existing /api/team/accept-invite)
        const authResult = await requireAuth(request);
        let actualUserId: string;
        let userEmail: string;

        if ('response' in authResult) {
            if (!user_id) return authResult.response;
            actualUserId = user_id;
            userEmail = email || '';
        } else {
            actualUserId = authResult.user.id;
            userEmail = email || authResult.user.email;
            if (user_id && user_id !== actualUserId) {
                return NextResponse.json(
                    { error: 'Cannot accept invites for another user' },
                    { status: 403 }
                );
            }
        }

        const normalizedEmail = userEmail.toLowerCase().trim();

        // Find all pending, non-expired org invites for this email
        const { data: pendingInvites, error: fetchError } = await supabaseAdmin
            .from('org_invites')
            .select('*')
            .eq('email', normalizedEmail)
            .eq('status', 'pending')
            .gt('expires_at', new Date().toISOString());

        if (fetchError) {
            console.error('Error fetching pending org invites:', fetchError);
            return NextResponse.json(
                { error: 'Failed to fetch pending invites' },
                { status: 500 }
            );
        }

        if (!pendingInvites || pendingInvites.length === 0) {
            return NextResponse.json({
                success: true,
                message: 'No pending org invites found',
                accepted_count: 0,
            });
        }

        let acceptedCount = 0;
        const orgs: string[] = [];

        for (const invite of pendingInvites) {
            try {
                // Insert into org_members — skip on conflict (already a member)
                const { error: memberError } = await supabaseAdmin
                    .from('org_members')
                    .insert({ org_id: invite.org_id, user_id: actualUserId, role: invite.role });

                if (memberError) {
                    // If already a member (23505 unique violation), still mark invite accepted
                    if (memberError.code !== '23505') {
                        console.error('Error adding to org:', memberError);
                        continue;
                    }
                }

                // Mark invite as accepted
                await supabaseAdmin
                    .from('org_invites')
                    .update({ status: 'accepted', accepted_at: new Date().toISOString() })
                    .eq('id', invite.id);

                acceptedCount++;

                // Get org name for response
                const { data: org } = await supabaseAdmin
                    .from('organizations')
                    .select('name')
                    .eq('id', invite.org_id)
                    .single();
                if (org) orgs.push(org.name);
            } catch (error) {
                console.error('Error processing org invite:', error);
            }
        }

        return NextResponse.json({
            success: true,
            message: acceptedCount > 0
                ? `Successfully joined ${acceptedCount} organization(s)`
                : 'No new organizations to join',
            accepted_count: acceptedCount,
            orgs,
        });
    } catch (error) {
        console.error('Error accepting org invites:', error);
        return NextResponse.json(
            { error: 'Internal server error' },
            { status: 500 }
        );
    }
}
```

**File 3 — `src/contexts/auth-context.tsx` (UPDATE):**

Add a `checkAndAcceptOrgInvites` function alongside the existing `checkAndAcceptInvites`. Call it in the same places.

Add this function after the existing `checkAndAcceptInvites`:

```typescript
async function checkAndAcceptOrgInvites(userId: string, email: string) {
    try {
        const response = await fetch('/api/orgs/accept-invite', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user_id: userId, email }),
        });
        if (response.ok) {
            const data = await response.json();
            if (data.accepted_count > 0) {
                console.log(`Joined ${data.accepted_count} org(s):`, data.orgs);
            }
        }
    } catch (error) {
        console.error('Error checking for pending org invites:', error);
    }
}
```

Then update the three places where `checkAndAcceptInvites` is called to ALSO call `checkAndAcceptOrgInvites`:

1. In the `getSession` initial load block (around line 56): add `checkAndAcceptOrgInvites(session.user.id, session.user.email);` right after the existing `checkAndAcceptInvites` call
2. In the `onAuthStateChange` handler (around line 73): add `checkAndAcceptOrgInvites(session.user.id, session.user.email);` right after the existing `checkAndAcceptInvites` call

Both calls share the same `inviteCheckDone` ref guard — the guard is already per-user-id so both old and new invite checks fire together.
  </action>
  <verify>
1. `npm run build` passes — no type errors in any of the three files
2. `src/app/auth/confirm/route.ts` uses `verifyOtp` (not `exchangeCodeForSession`)
3. `src/app/api/orgs/accept-invite/route.ts` queries `org_invites` (not `team_invites`) and inserts into `org_members` (not `user_dso_access`)
4. `src/contexts/auth-context.tsx` calls both `checkAndAcceptInvites` and `checkAndAcceptOrgInvites` on SIGNED_IN
5. The auth confirm route creates a Supabase server client using `cookies()` from `next/headers`
  </verify>
  <done>
Complete org invite flow works end-to-end: admin sends invite → new user gets email → clicks link → /auth/confirm verifies token → session established → SIGNED_IN fires → checkAndAcceptOrgInvites adds user to org_members. Existing users are added directly without email.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes — all four files compile without errors
2. New user invite flow: POST /api/orgs/[id]/invites with new email → org_invites row created + inviteUserByEmail called → user clicks link → GET /auth/confirm verifies token → redirect to / → SIGNED_IN → POST /api/orgs/accept-invite → user in org_members
3. Existing user invite flow: POST /api/orgs/[id]/invites with existing email → user added directly to org_members (no email sent)
4. Duplicate pending invite returns 409
5. auth-context calls both old (team) and new (org) invite acceptance on SIGNED_IN
6. No cross-org leakage: accept-invite only processes invites matching the user's email
</verification>

<success_criteria>
- An admin can invite a user by email to the org (MBR-01)
- The invited user can accept and join the org (MBR-02)
- Existing users are added directly to org_members (no broken inviteUserByEmail call)
- New users receive an email, click the link, and land in the app with org membership
- The invite is scoped to the org — no DSOs are granted, no cross-org access
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-invite-system/03-02-SUMMARY.md`
</output>
